<?php
namespace Leafcutter\Events;

use Leafcutter\Leafcutter;

/**
 * Provider for allowing other classes to hook into and generate events.
 */
class EventProvider
{
    private $leafcutter;
    private $subscribers = [];

    public function __construct(Leafcutter $leafcutter)
    {
        $this->leafcutter = $leafcutter;
    }

    /**
     * Call listener methods of the name $method, passing them the given $subject.
     * Returns this first non-null result returned by a subscriber.
     *
     * @param string $method
     * @param mixed $subject
     * @return mixed resulting output
     */
    public function dispatchFirst(string $method, $subject)
    {
        $this->leafcutter->logger()->debug('EventProvider: dispatchFirst: ' . $method . ': ' . $this->logSubject($subject));
        foreach (array_reverse($this->subscribers[$method] ?? []) as $fn) {
            $this->leafcutter->logger()->debug('EventProvider: handler: ' . get_class($fn[0]) . '::' . $fn[1]);
            if ($result = call_user_func($fn, $subject, $this->leafcutter)) {
                return $result;
            }
        }
        return null;
    }

    /**
     * Passes the given $subject to each listener in turn (last-registered, first-called),
     * passing each listener's output to the next one. Returns the final output.
     *
     * @param string $method
     * @param mixed $subject
     * @return mixed
     */
    public function dispatchAll(string $method, $subject)
    {
        $this->leafcutter->logger()->debug('EventProvider: dispatchAll: ' . $method . ': ' . $this->logSubject($subject));
        foreach ($this->subscribers[$method] ?? [] as $fn) {
            $this->leafcutter->logger()->debug('EventProvider: handler: ' . get_class($fn[0]) . '::' . $fn[1]);
            $subject = call_user_func($fn, $subject, $this->leafcutter);
        }
        return $subject;
    }

    /**
     * Pass an object to all listeners, allowing them to operate on it, but never replacing it.
     *
     * @param string $method
     * @param object $event
     * @return object
     */
    public function dispatchEvent(string $method, $event)
    {
        if (!is_object($event)) {
            throw new \Exception("\$event must be an object");
        }
        $this->leafcutter->logger()->debug('EventProvider: dispatchEvent: ' . $method . ': ' . $this->logSubject($event));
        foreach ($this->subscribers[$method] ?? [] as $fn) {
            $this->leafcutter->logger()->debug('EventProvider: handler: ' . get_class($fn[0]) . '::' . $fn[1]);
            call_user_func($fn, $event, $this->leafcutter);
        }
        return $event;
    }

    /**
     * Add a subscriber to events generated by this provider.
     *
     * Automatically scans the object for public methods beginning with "on"
     * and uses them as listeners, such as onSomeEvent
     *
     * @param object $subscriber
     * @return void
     */
    public function addSubscriber($subscriber)
    {
        if (!is_object($subscriber)) {
            throw new \Exception("\$subscriber must be an object");
        }
        foreach ($this->getMethods($subscriber) as $method) {
            $this->subscribers[$method][] = [$subscriber, $method];
        }
    }

    /**
     * Remove a subscriber.
     *
     * @param object $subscriber
     * @return void
     */
    public function removeSubscriber($subscriber)
    {
        if (!is_object($subscriber)) {
            throw new \Exception("\$subscriber must be an object");
        }
        foreach ($this->getMethods($subscriber) as $method) {
            $this->subscribers[$method] = array_filter(
                $this->subscribers[$method],
                function ($e) use ($subscriber) {
                    return $e[0] != $subscriber;
                }
            );
        }
    }

    /**
     * List all valid onSomeEvent-type methods from a given object.
     *
     * @param object $subscriber
     * @return array
     */
    protected function getMethods($subscriber): array
    {
        if (!is_object($subscriber)) {
            throw new \Exception("\$subscriber must be an object");
        }
        return array_filter(
            get_class_methods($subscriber),
            function ($e) {
                return preg_match('/^on([A-Z]+[a-z_]*[a-zA-Z0-9]*)+$/', $e);
            }
        );
    }

    /**
     * Turn an object into something that can be represented as a string in logs.
     *
     * @param $subject
     * @return void
     */
    protected function logSubject($subject)
    {
        if (is_object($subject)) {
            if (method_exists($subject, 'logString')) {
                return $subject->logString();
            }
            return get_class($subject);
        }
        if (is_bool($subject) || is_array($subject)) {
            return serialize($subject);
        }
        return "$subject";
    }
}
